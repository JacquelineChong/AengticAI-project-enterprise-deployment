<section id="introduction">
    <h2>Introduction: Why a Data Lake is the Foundation of Data Transformation</h2>
    
    <div class="key-concept">
        <h3>Beyond Tool Implementation</h3>
        <p>Unlike traditional IT projects where systems are deployed and then used as-is, a data lake is a living foundation that grows in value through continuous contribution and utilization.</p>
        
        <div class="example-box">
            <h4>What This Means for a F&B Chain:</h4>
            <p>Imagine if we implemented a new POS system in all your restaurants. Once installed, it basically works the same way day after day. The system helps you process orders faster, but it doesn't inherently become more valuable over time.</p>
            <p>In contrast, think about your master chef who has been with you for 20 years. Every day, they learn something new about customer preferences, adjust recipes, and improve efficiency. The longer they work, the more valuable their knowledge becomes.</p>
            <p>A data lake works like your master chef, not like your POS system. Each day it collects more information about your customers, sales patterns, and operations. Over time, it builds an increasingly valuable repository of knowledge that can help you make better business decisions. The data lake becomes smarter and more valuable the more you use it, unlike traditional IT systems that just maintain their original functionality.</p>
        </div>
    </div>
    
    <div class="key-concept">
        <h3>Value Creation Model</h3>
        <p>Traditional IT projects follow a linear value creation model (requirements → build → use), while data lakes follow a flywheel model where each use generates more data and insights, creating compounding value.</p>
        
        <div class="example-box">
            <h4>What This Means for a F&B Chain:</h4>
            <p>When you open a new branch, you follow a linear process: find a location, renovate the space, hire staff, train them, and open for business. The value is created once the restaurant is operational.</p>
            <p>Consider your loyalty program. Initially, you might have basic customer information and purchase history. As you analyze this data, you notice certain customers always order milk tea on Mondays. You create a Monday milk tea promotion, which attracts more customers and generates more data about preferences. This new data reveals that these Monday customers also prefer pineapple buns, leading to a bundled promotion. Each insight creates new opportunities, which generate more data, which leads to more insights – creating a continuous cycle of increasing value.</p>
            <p>With traditional IT projects, you invest once and get a fixed return. With a data lake, your initial investment generates increasing returns over time as each data-driven decision creates more valuable data for future decisions.</p>
        </div>
    </div>
    
    <div class="key-concept">
        <h3>Ownership Model</h3>
        <p>Traditional IT projects are "built by IT, used by business," whereas data lakes are "co-created and continuously evolved" by both IT and business.</p>
        
        <div class="example-box">
            <h4>What This Means for a F&B Chain:</h4>
            <p>Think about your kitchen equipment. The equipment supplier installs the stoves and refrigerators, and then your chefs use them. The supplier doesn't need to understand how to make Hong Kong-style milk tea or the perfect scrambled egg sandwich – they just provide the tools.</p>
            <p>Now imagine if you had a magical kitchen that could adapt to how your chefs cook. For this to work, both the kitchen designer and the chefs would need to collaborate continuously. The chefs would need to explain their cooking techniques, and the kitchen designer would need to understand the culinary process to create the right adaptations.</p>
            <p>A data lake is like this magical kitchen. It can't be simply built by IT and handed over to the business. Your restaurant managers know which dishes are popular at different times of day, your procurement team understands seasonal ingredient pricing, and your marketing team knows which promotions attract new customers. All of this domain expertise must be combined with technical knowledge to create a truly valuable data ecosystem. Without continuous collaboration between business experts and technical staff, the data lake becomes just another underutilized IT system.</p>
        </div>
    </div>
    
    <div class="key-message">
        <h3>Key Message:</h3>
        <p>The data lake is not a one-time project but the foundation of an evolving data ecosystem that requires continuous business participation. It's a strategic asset that becomes more valuable over time through collaboration between business and technical teams.</p>
    </div>
    
    <div class="visualization">
        <h3>A data transformation approach results in collaboration that creates ongoing value</h3>
        <div class="diagram-container">
            <canvas id="dataTransformationCanvas" width="1000" height="600"></canvas>
        </div>
        <div class="diagram-caption">
            <p><strong>Flow of data ———→</strong></p>
            <p><em>Continuous collaboration between business departments and technical teams creates a self-reinforcing cycle that unlocks increasing value from your data assets.</em></p>
        </div>
    </div>
</section>

<style>
    #introduction {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
    }
    
    h2 {
        color: #2c3e50;
        border-bottom: 2px solid #3498db;
        padding-bottom: 10px;
        margin-bottom: 30px;
    }
    
    h3 {
        color: #2c3e50;
        margin-top: 30px;
    }
    
    .key-concept {
        margin-bottom: 40px;
        border-left: 4px solid #3498db;
        padding-left: 20px;
    }
    
    .example-box {
        background-color: #f8f9fa;
        border-radius: 8px;
        padding: 20px;
        margin: 15px 0;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .example-box h4 {
        color: #3498db;
        margin-top: 0;
    }
    
    .key-message {
        background-color: #e3f2fd;
        border-radius: 8px;
        padding: 20px;
        margin: 30px 0;
        border-left: 4px solid #2196f3;
    }
    
    .visualization {
        margin-top: 50px;
    }
    
    .diagram-container {
        max-width: 1000px;
        margin: 0 auto;
        border: 1px solid #e0e0e0;
        background-color: white;
    }
    
    .diagram-caption {
        margin-top: 20px;
        max-width: 1000px;
        margin-left: auto;
        margin-right: auto;
        text-align: right;
        font-size: 0.9em;
    }
    
    canvas {
        display: block;
        margin: 0 auto;
        max-width: 100%;
        height: auto;
    }
</style>

<script>
    window.addEventListener('load', function() {
        // Get the canvas element and its 2D context
        const canvas = document.getElementById('dataTransformationCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas dimensions based on its display size
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
            canvas.width = displayWidth;
            canvas.height = displayHeight;
        }
        
        // Define colors
        const colors = {
            background: '#ffffff',
            boxBorder: '#333333',
            sectionHeading: '#333333',
            systemBox: '#ffffff',
            dataStoreBox: '#3498db',
            dataProductBox: '#f0f0f0',
            consumptionBox: '#4169e1',
            useCaseBox: '#ffffff',
            text: '#000000',
            textLight: '#ffffff'
        };
        
        // Define column widths and spacing
        const padding = 25;
        const headerHeight = 80;
        const columnSpacing = 15;
        const columns = 5;
        const columnWidth = (canvas.width - (padding * 2) - (columnSpacing * (columns - 1))) / columns;
        
        // Drawing functions
        function drawRoundedRect(x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            
            if (fill) {
                ctx.fillStyle = fill;
                ctx.fill();
            }
            
            if (stroke) {
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        function drawCircle(x, y, radius, fill, stroke) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.closePath();
            
            if (fill) {
                ctx.fillStyle = fill;
                ctx.fill();
            }
            
            if (stroke) {
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        function drawArrow(fromX, fromY, toX, toY) {
            // Draw line
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.strokeStyle = colors.boxBorder;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw arrowhead
            const headLength = 10;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI/6), toY - headLength * Math.sin(angle - Math.PI/6));
            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI/6), toY - headLength * Math.sin(angle + Math.PI/6));
            ctx.closePath();
            ctx.fillStyle = colors.boxBorder;
            ctx.fill();
        }
        
        function drawBracket(startX, startY, endX, endY) {
            const radius = 15;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX - radius, startY);
            ctx.quadraticCurveTo(startX - radius * 2, startY, startX - radius * 2, startY + radius);
            ctx.lineTo(startX - radius * 2, endY - radius);
            ctx.quadraticCurveTo(startX - radius * 2, endY, startX - radius, endY);
            ctx.lineTo(startX, endY);
            ctx.strokeStyle = colors.boxBorder;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // Draw section headers
        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = colors.sectionHeading;
        ctx.textAlign = 'center';
        
        const headers = [
            "Data\nSources",
            "Data\nPlatform", 
            "Data\nProducts", 
            "Consumption\nArchetypes", 
            "Use\nCases"
        ];
        
        headers.forEach((header, index) => {
            const x = padding + (columnWidth + columnSpacing) * index + columnWidth/2;
            const lines = header.split('\n');
            
            lines.forEach((line, lineIndex) => {
                ctx.fillText(
                    line, 
                    x, 
                    padding + 20 + lineIndex * 20
                );
            });
        });
        
        // Draw flow of data text
        ctx.font = 'bold 14px Arial';
        ctx.fillStyle = colors.sectionHeading;
        ctx.textAlign = 'right';
        ctx.fillText("Flow of data", canvas.width - padding - 20, padding + 10);
        
        // Draw arrow for flow of data
        drawArrow(canvas.width - padding - 15, padding + 10, canvas.width - padding, padding + 10);
        
        // Column 1: Data Sources
        const sourceY = headerHeight + padding;
        const sourceHeight = 120;
        const sourceGap = 15;
        
        const sources = [
            { name: "Core POS\nSystems", height: sourceHeight },
            { name: "Inventory\nSystem", height: sourceHeight },
            { name: "External\nData", height: sourceHeight }
        ];
        
        let currentY = sourceY;
        sources.forEach(source => {
            drawRoundedRect(
                padding, 
                currentY, 
                columnWidth, 
                source.height, 
                10, 
                colors.systemBox, 
                colors.boxBorder
            );
            
            // Add text
            ctx.font = '14px Arial';
            ctx.fillStyle = colors.text;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const lines = source.name.split('\n');
            lines.forEach((line, index) => {
                ctx.fillText(
                    line, 
                    padding + columnWidth/2, 
                    currentY + source.height/2 - (lines.length - 1) * 10 + index * 20
                );
            });
            
            currentY += source.height + sourceGap;
        });
        
        // Column 2: Data Platform
        const platformY = headerHeight + padding;
        const platformHeight = 140;
        const platformGap = 15;
        
        const platforms = [
            { name: "Data\nWarehouse", height: platformHeight },
            { name: "Raw Data\nLake", height: platformHeight },
            { name: "Operational\nData Store", height: platformHeight }
        ];
        
        currentY = platformY;
        platforms.forEach(platform => {
            drawRoundedRect(
                padding + columnWidth + columnSpacing, 
                currentY, 
                columnWidth, 
                platform.height, 
                10, 
                colors.dataStoreBox, 
                colors.boxBorder
            );
            
            // Add text
            ctx.font = '14px Arial';
            ctx.fillStyle = colors.textLight;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const lines = platform.name.split('\n');
            lines.forEach((line, index) => {
                ctx.fillText(
                    line, 
                    padding + columnWidth + columnSpacing + columnWidth/2, 
                    currentY + platform.height/2 - (lines.length - 1) * 10 + index * 20
                );
            });
            
            currentY += platform.height + platformGap;
        });
        
        // Draw arrow from column 1 to column 2
        drawArrow(
            padding + columnWidth, 
            headerHeight + padding + (sources.length * sourceHeight + (sources.length - 1) * sourceGap) / 2, 
            padding + columnWidth + columnSpacing, 
            headerHeight + padding + (platforms.length * platformHeight + (platforms.length - 1) * platformGap) / 2
        );
        
        // Column 3: Data Products
        const productX = padding + 2 * (columnWidth + columnSpacing);
        const productY = headerHeight + padding;
        const productHeight = 380;  // Tall enough to span most of the diagram
        const productRadius = 25;
        const productGap = 15;
        
        // Draw main rounded rectangle
        drawRoundedRect(
            productX, 
            productY, 
            columnWidth, 
            productHeight, 
            20, 
            colors.dataProductBox, 
            colors.boxBorder
        );
        
        // Add data product circles
        const products = [
            "Menu & Pricing",
            "Customer",
            "Branch",
            "Inventory",
            "Staff"
        ];
        
        const productCircleRadius = 30;
        const productCircleY = productY + 60;
        const productCircleGap = 65;
        
        products.forEach((product, index) => {
            const y = productCircleY + index * productCircleGap;
            
            // Draw circle
            drawCircle(
                productX + columnWidth/2, 
                y, 
                productCircleRadius, 
                '#ffffff', 
                colors.boxBorder
            );
            
            // Add text
            ctx.font = '12px Arial';
            ctx.fillStyle = colors.text;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Split text if needed
            if (product.includes(" ")) {
                const parts = product.split(" ");
                ctx.fillText(parts[0], productX + columnWidth/2, y - 8);
                ctx.fillText(parts[1], productX + columnWidth/2, y + 8);
            } else {
                ctx.fillText(product, productX + columnWidth/2, y);
            }
        });
        
        // Draw bracket from column 2 to column 3
        drawBracket(
            productX, 
            productY + 30, 
            productX, 
            productY + productHeight - 30
        );
        
        // Column 4: Consumption Archetypes
        const consumptionX = padding + 3 * (columnWidth + columnSpacing);
        const consumptionY = headerHeight + padding + 20;
        const consumptionHeight = 60;
        const consumptionGap = 25;
        
        const consumptions = [
            "Business\nIntelligence",
            "Advanced\nAnalytics",
            "Reporting",
            "External\nData Sharing",
            "Discovery\nSandbox"
        ];
        
        currentY = consumptionY;
        consumptions.forEach((consumption, index) => {
            drawRoundedRect(
                consumptionX, 
                currentY, 
                columnWidth, 
                consumptionHeight, 
                20, 
                colors.consumptionBox, 
                colors.boxBorder
            );
            
            // Add text
            ctx.font = '14px Arial';
            ctx.fillStyle = colors.textLight;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const lines = consumption.split('\n');
            lines.forEach((line, lineIndex) => {
                ctx.fillText(
                    line, 
                    consumptionX + columnWidth/2, 
                    currentY + consumptionHeight/2 - (lines.length - 1) * 10 + lineIndex * 20
                );
            });
            
            // Draw horizontal lines connecting to data products
            const productCircleY = productY + 60 + (Math.min(index, products.length - 1) * productCircleGap);
            
            // Connect to appropriate data product or to multiple
            if (index < products.length) {
                drawArrow(
                    productX + columnWidth, 
                    productCircleY, 
                    consumptionX, 
                    currentY + consumptionHeight/2
                );
            }
            
            currentY += consumptionHeight + consumptionGap;
        });
        
        // Column 5: Use Cases
        const useCaseX = padding + 4 * (columnWidth + columnSpacing);
        const useCaseY = headerHeight + padding + 20;
        const useCaseHeight = 60;
        const useCaseGap = 10;
        
        const useCases = [
            "Mobile Ordering\nApp",
            "Customer Loyalty\nProgram",
            "Menu\nOptimization",
            "Staff Scheduling\nAssistant",
            "Financial\nReporting",
            "Customer Churn\nPrediction",
            "Inventory\nOptimization"
        ];
        
        currentY = useCaseY;
        useCases.forEach((useCase, index) => {
            drawRoundedRect(
                useCaseX, 
                currentY, 
                columnWidth, 
                useCaseHeight, 
                10, 
                colors.useCaseBox, 
                colors.boxBorder
            );
            
            // Add text
            ctx.font = '13px Arial';
            ctx.fillStyle = colors.text;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const lines = useCase.split('\n');
            lines.forEach((line, lineIndex) => {
                ctx.fillText(
                    line, 
                    useCaseX + columnWidth/2, 
                    currentY + useCaseHeight/2 - (lines.length - 1) * 10 + lineIndex * 20
                );
            });
            
            // Connect to consumption archetypes
            // First 2 use cases connect to Business Intelligence
            if (index < 2) {
                drawArrow(
                    consumptionX + columnWidth, 
                    consumptionY + consumptionHeight/2, 
                    useCaseX, 
                    currentY + useCaseHeight/2
                );
            }
            // Next 2 use cases connect to Advanced Analytics
            else if (index < 4) {
                drawArrow(
                    consumptionX + columnWidth, 
                    consumptionY + consumptionHeight + consumptionGap + consumptionHeight/2, 
                    useCaseX, 
                    currentY + useCaseHeight/2
                );
            }
            // Next use case connects to Reporting
            else if (index < 5) {
                drawArrow(
                    consumptionX + columnWidth, 
                    consumptionY + 2 * (consumptionHeight + consumptionGap) + consumptionHeight/2, 
                    useCaseX, 
                    currentY + useCaseHeight/2
                );
            }
            // Next use case connects to External Data Sharing
            else if (index < 6) {
                drawArrow(
                    consumptionX + columnWidth, 
                    consumptionY + 3 * (consumptionHeight + consumptionGap) + consumptionHeight/2, 
                    useCaseX, 
                    currentY + useCaseHeight/2
                );
            }
            // Last use case connects to Discovery Sandbox
            else {
                drawArrow(
                    consumptionX + columnWidth, 
                    consumptionY + 4 * (consumptionHeight + consumptionGap) + consumptionHeight/2, 
                    useCaseX, 
                    currentY + useCaseHeight/2
                );
            }
            
            currentY += useCaseHeight + useCaseGap;
        });
    });
</script>
